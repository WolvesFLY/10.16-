#include<stdio.h>
int main() {
	int x[10],a;
	double sum=0;
	for(int i=0; i<10; i++) {
		scanf("%d",&x[i]);
	}
	for(int i=0; i<10; i++) {
		for(int j=i+1; j<10; j++) {
			if(x[i]>x[j]) {
				a=x[i];
				x[i]=x[j];
				x[j]=a;
			}
		}
	}
	for(int i=1; i<9; i++) {
		sum+=x[i];
	}
	printf("%.2lf",sum/8);
	return 0;
}
以下是对这段代码的解释：
一、整体功能
这段 C 语言代码的作用是读取 10 个整数，对这些整数进行排序，然后去掉最大值和最小值后计算剩余 8 个整数的平均值，并输出结果保留两位小数。
二、具体步骤
定义数组和变量：
int x[10]：定义一个包含 10 个整数的数组，用于存储输入的整数。
int a：用于在排序过程中临时存储交换的值。
double sum = 0：用于累加中间 8 个整数的值。
输入 10 个整数：
for(int i = 0; i < 10; i++) { scanf("%d", &x[i]); }：循环读取 10 个整数存入数组 x。
对数组进行排序：
使用嵌套的两个循环进行冒泡排序，外层循环控制轮数，内层循环进行相邻元素的比较和交换。
如果 x[i] > x[j]，则交换两个元素的值，确保较大的元素在后面。
计算中间 8 个整数的和：
for(int i = 1; i < 9; i++) { sum += x[i]; }：循环累加数组中索引从 1 到 8 的元素，即去掉最大值和最小值后的中间 8 个整数。
计算并输出平均值：
printf("%.2lf", sum / 8);：输出中间 8 个整数的平均值，保留两位小数。
三、注意事项
排序算法使用了冒泡排序，对于较大规模的数据可能效率较低。可以考虑使用更高效的排序算法，如快速排序等。
代码假设输入的整数是合理的，没有进行错误处理。如果输入可能不合法，需要添加相应的错误处理代码。
冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
一、基本原理
比较相邻的元素。如果第一个比第二个大，就交换它们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
二、示例
比如有一个数组 [5, 3, 8, 4, 2]。
第一次遍历：
比较 5 和 3，因为 5 > 3，所以交换，数组变为 [3, 5, 8, 4, 2]。
比较 5 和 8，不交换。
比较 8 和 4，因为 8 > 4，所以交换，数组变为 [3, 5, 4, 8, 2]。
比较 8 和 2，因为 8 > 2，所以交换，数组变为 [3, 5, 4, 2, 8]。此时第一轮遍历结束，最大的数 8 被移到了最后。
第二次遍历：
比较 3 和 5，不交换。
比较 5 和 4，因为 5 > 4，所以交换，数组变为 [3, 4, 5, 2, 8]。
比较 5 和 2，因为 5 > 2，所以交换，数组变为 [3, 4, 2, 5, 8]。
第三次遍历：
比较 3 和 4，不交换。
比较 4 和 2，因为 4 > 2，所以交换，数组变为 [3, 2, 4, 5, 8]。
第四次遍历：
比较 3 和 2，因为 3 > 2，所以交换，数组变为 [2, 3, 4, 5, 8]。
经过四次遍历，数组完成了排序。
三、特点
优点：
简单易懂，容易实现。
缺点：
效率较低，尤其是对于大规模数据。其时间复杂度为 O（n^2），其中 n 是待排序元素的数量。
冒泡排序适用于小规模数据的排序，对于大规模数据，通常会使用更高效的排序算法，如快速排序、归并排序等。